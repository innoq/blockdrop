<!DOCTYPE HTML>
<html>
    <head>
		<script src="js/Three.js"> </script>
		<script>
/**
Ajax Request
*/

var xmlHttp = null;

function getBoardInfo() {
	var Url = "http://127.0.0.1:9998/board";
	xmlHttp = new XMLHttpRequest();
	xmlHttp.onreadystatechange = processBoardRequest;
	xmlHttp.open("GET", Url, true);
	xmlHttp.send(null);
}

function processBoardRequest() {
	if (xmlHttp.readyState == 4 && xmlHttp.status == 200) {
		if (xmlHttp.responseText == "Not found") {
			document.getElementById("infoText").value = "Nothing found";
		} else {
			var value = xmlHttp.responseText;
            // TODO Start Parsing
			document.getElementById("debug").value = value;
		}
	}
}

var iFrequency = 500; // in ms
var myInterval = 0;

function startLoop() {
	if(myInterval > 0) clearInterval(myInterval);  // stop
	myInterval = setInterval( "getBoardInfo()", iFrequency );  // run
}
getBoardInfo();
startLoop();
		
		
		
		/**
		THREE.js
		*/
		
			var WIDTH = 1000;
			var HEIGHT = 800;
			var camera = new THREE.PerspectiveCamera(45, WIDTH / HEIGHT, 45, 10000);
			
			var cube = new THREE.Mesh(new THREE.CubeGeometry(100,100,100),
			               new THREE.MeshNormalMaterial());
			var three;
			
			function cubeUp() {
				var x, y;		
			    x = cube.position.x;
				cube.position.x = x + 100;
				y = cube.position.y;
				cube.position.y = y + 100;
				cube.geometry.dynamic = true;
				render();
			}
			
			function cubeLeft() {
				var y;		
			    y = cube.position.y;
				cube.position.y = y + 100;
				cube.geometry.dynamic = true;
				render();
			}
			
			function cubeRight() {
				var x;		
			    x = cube.position.x;
				cube.position.x = x + 100;
				cube.geometry.dynamic = true;
				render();
			}
			
			function cubeDown() {
				var x, y;		
			    x = cube.position.x;
				cube.position.x = x - 100;
				y = cube.position.y;
				cube.position.y = y - 100;
				cube.geometry.dynamic = true;
				render();
			}
			
			function onDocumentKeyDown(event) {
				
			}
			
			function drawCoordinateSystem(scene) {
				// COORDINATE SYS
				var line, lineGeometry;

				// x - red
				lineGeometry = new THREE.Geometry();
				lineGeometry.vertices.push( new THREE.Vertex() );
				lineGeometry.vertices.push( new THREE.Vertex( new THREE.Vector3( 1000, 0, 0 ) ) );
				line = new THREE.Line( lineGeometry, new THREE.LineBasicMaterial( { color : 0xff0000 } ) );
				scene.add( line );

				// y - green
				lineGeometry = new THREE.Geometry();
				lineGeometry.vertices.push( new THREE.Vertex() );
				lineGeometry.vertices.push( new THREE.Vertex( new THREE.Vector3( 0, 1000, 0 ) ) );
				line = new THREE.Line( lineGeometry, new THREE.LineBasicMaterial( { color : 0x00ff00 } ) );
				scene.add( line );

				// z - blue
				lineGeometry = new THREE.Geometry();
				lineGeometry.vertices.push( new THREE.Vertex() );
 				lineGeometry.vertices.push( new THREE.Vertex( new THREE.Vector3( 0, 0, 1000 ) ) );
 				line = new THREE.Line( lineGeometry, new THREE.LineBasicMaterial( { color : 0x0000ff } ) );
 				scene.add( line );
			}
			
			function drawBaseGrid(scene) {
				var line, lineGeo, p1, p2;
				
				for (var i = 100; i <= 500; i = i + 100) {
					p1 = new THREE.Vertex( new THREE.Vector3( 0, i, 0 ) );
					p2 = new THREE.Vertex( new THREE.Vector3( 500, i, 0 ) );
					lineGeo = new THREE.Geometry();
					lineGeo.vertices.push( p1 );
					lineGeo.vertices.push( p2 );
				 	line = new THREE.Line( lineGeo, new THREE.LineBasicMaterial( { color : 0x000 } ) );
					scene.add( line );
				}
				
				for (var i = 100; i <= 500; i = i + 100) {
					p1 = new THREE.Vertex( new THREE.Vector3( i, 0, 0 ) );
					p2 = new THREE.Vertex( new THREE.Vector3( i, 500, 0 ) );
					lineGeo = new THREE.Geometry();
					lineGeo.vertices.push( p1 );
					lineGeo.vertices.push( p2 );
				 	line = new THREE.Line( lineGeo, new THREE.LineBasicMaterial( { color : 0x000 } ) );
					scene.add( line );
				}
			}
			
			function drawCubes(scene) {
				cube.position.x = 450;
				cube.position.y = 450;
				cube.position.z = 50;
				
				// set the geometry to dynamic
				// so that it allow updates
				cube.geometry.dynamic = true;

				// changes to the vertices
				cube.geometry.__dirtyVertices = true;

				// changes to the normals
				cube.geometry.__dirtyNormals = true;
				
				scene.add(cube);
			}
			
			function render() {
				 three.renderer.render(three.scene, three.camera);
			}
		
		    window.onload = function(){
			
			    var angularSpeed = 0.2; // revolutions per second
		        var lastTime = 0;

		        var renderer = new THREE.WebGLRenderer();
		        renderer.setSize(WIDTH, HEIGHT);
		        document.body.appendChild(renderer.domElement);
		
		        var camera = new THREE.PerspectiveCamera(45, WIDTH / HEIGHT, 45, 10000);
		        
				camera.position.x = -750;
				camera.position.y = -750;
				camera.position.z = 1500;
				camera.lookAt(new THREE.Vector3());
				
				camera.rotation.z = -39.25 * (Math.PI / 180);
				
				
		        // scene
		        var scene = new THREE.Scene();

		        drawCoordinateSystem(scene);
				
				drawBaseGrid(scene);
				
				// plane
		        var plane = new THREE.Mesh(new THREE.PlaneGeometry(500, 500), new THREE.MeshBasicMaterial({
		            color: 0xeeeeee
		        }));
				plane.position.x = 250;
				plane.position.y = 250;
				plane.overdraw = true;
		        scene.add(plane);
				
				drawCubes(scene);
				
		        // create wrapper object that contains three.js objects
		        three = {
		            renderer: renderer,
		            camera: camera,
		            scene: scene,
		            plane: plane
		        };
		
				render();
				
				document.addEventListener( 'keydown', onDocumentKeyDown, false );
				
		    };	
		</script>
    </head>
    <body>
        <canvas id="myCanvas" width="10" height="10">
        </canvas>
		<input type="button" onClick="cubeLeft()" value="left" />
		<input type="button" onClick="cubeUp()" value="up" />
		<input type="button" onClick="cubeDown()" value="down" />
		<input type="button" onClick="cubeRight()" value="right" />
		<textarea id="debug" cols="40" rows="8"> </textarea>
    </body>
</html>