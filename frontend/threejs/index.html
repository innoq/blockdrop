<!DOCTYPE HTML>
<html>
    <head>
		<script src="js/Three.js">
		
		</script>
		<script>
		
			var WIDTH = 1000;
			var HEIGHT = 800;
			var camera = new THREE.PerspectiveCamera(45, WIDTH / HEIGHT, 45, 10000);
			var cubeGeo = new THREE.CubeGeometry(100, 100, 100);
			var cubeMaterial = new THREE.MeshLambertMaterial( { color: 0xdddddd, shading: THREE.SmoothShading } );
            
			var cubes = new Array();
			var three, cube;
            
			function cubeUp() {
				var x, y;		
			    x = cube.position.x;
				cube.position.x = x + 100;
				y = cube.position.y;
				cube.position.y = y + 100;
				cube.geometry.dynamic = true;
				render();
			}
			
			function cubeLeft() {
				var y;		
			    y = cube.position.y;
				cube.position.y = y + 100;
				cube.geometry.dynamic = true;
				render();
			}
			
			function cubeRight() {
				var x;		
			    x = cube.position.x;
				cube.position.x = x + 100;
				cube.geometry.dynamic = true;
				render();
			}
			
			function cubeDown() {
				var x, y;		
			    x = cube.position.x;
				cube.position.x = x - 100;
				y = cube.position.y;
				cube.position.y = y - 100;
				cube.geometry.dynamic = true;
				render();
			}
            
            function renderPositions() {
              var positions = JSON.parse(document.getElementById('input'));
              update(positions);
            }
            
			function getPositions() {
				return new Array([0,0,1], [1,1,0], [2,3,4]);	
			}
            
			function cameraBack() {
				camera.position.x = -750;
				camera.position.y = -750;
				camera.position.z = 1500;

				camera.up = new THREE.Vector3(0, 0, 1);
				camera.lookAt(new THREE.Vector3(0,0,750));
				render();
			}
			
			function cameraFront() {
				camera.position.z = 1500;
				camera.position.x = 1250;
				camera.position.y = 1250;
				camera.up = new THREE.Vector3( 0, 0, 1 );
				camera.lookAt(new THREE.Vector3(0,0,350));
				render();
			}
            
			function clearGrid() {
				for(var i = 0; i < cubes.length; i++) {
					three.scene.removeObject(cubes[i]);
				}
				
				cubes = new Array();
			}
            
            function worldPos(pos) {
              pos[0] = pos[0] + 50;
              pos[1] = pos[1] + 50;
              pos[2] = pos[2] + 50;
              return pos;
            }
			
			function drawCube(pos) {
              
				var c = new THREE.Mesh(cubeGeo, cubeMaterial);
                pos = worldPos(pos);
                
                c.position.x = pos[0];
				c.position.y = pos[1];
				c.position.z = pos[2];
                
                
                // set the geometry to dynamic
				// so that it allow updates
				c.geometry.dynamic = true;

				// changes to the vertices
				c.geometry.__dirtyVertices = true;

				// changes to the normals
				c.geometry.__dirtyNormals = true;
                
				three.scene.add(c);
				cubes.push(c);
			}
			
			function update(positions) {
              
				clearGrid();
				
				positions = getPositions();
				
				for (var i = 0; i <= 1000; i+= 100) {
					drawCube(new Array(0, 0, i + 50));
				}
                
				render();
			}
			
			function drawCoordinateSystem() {
				// COORDINATE SYS
				var line, lineGeometry;

				// x - red
				lineGeometry = new THREE.Geometry();
				lineGeometry.vertices.push( new THREE.Vertex() );
				lineGeometry.vertices.push( new THREE.Vertex( new THREE.Vector3( 1000, 0, 0 ) ) );
				line = new THREE.Line( lineGeometry, new THREE.LineBasicMaterial( { color : 0xff0000 } ) );
				three.scene.add( line );

				// y - green
				lineGeometry = new THREE.Geometry();
				lineGeometry.vertices.push( new THREE.Vertex() );
				lineGeometry.vertices.push( new THREE.Vertex( new THREE.Vector3( 0, 1000, 0 ) ) );
				line = new THREE.Line( lineGeometry, new THREE.LineBasicMaterial( { color : 0x00ff00 } ) );
				three.scene.add( line );

				// z - blue
				// lineGeometry = new THREE.Geometry();
				// lineGeometry.vertices.push( new THREE.Vertex() );
				// lineGeometry.vertices.push( new THREE.Vertex( new THREE.Vector3( 0, 0, 1000 ) ) );
				// line = new THREE.Line( lineGeometry, new THREE.LineBasicMaterial( { color : 0x0000ff } ) );
				// three.scene.add( line );
			}
			
			function drawBaseGrid() {
				var line, lineGeo, p1, p2;
				
				for (var i = 100; i <= 500; i = i + 100) {
					p1 = new THREE.Vertex( new THREE.Vector3( 0, i, 0 ) );
					p2 = new THREE.Vertex( new THREE.Vector3( 500, i, 0 ) );
					lineGeo = new THREE.Geometry();
					lineGeo.vertices.push( p1 );
					lineGeo.vertices.push( p2 );
				 	line = new THREE.Line( lineGeo, new THREE.LineBasicMaterial( { color : 0x000 } ) );
					three.scene.add( line );
				}
				
				for (var i = 100; i <= 500; i = i + 100) {
					p1 = new THREE.Vertex( new THREE.Vector3( i, 0, 0 ) );
					p2 = new THREE.Vertex( new THREE.Vector3( i, 500, 0 ) );
					lineGeo = new THREE.Geometry();
					lineGeo.vertices.push( p1 );
					lineGeo.vertices.push( p2 );
				 	line = new THREE.Line( lineGeo, new THREE.LineBasicMaterial( { color : 0x000 } ) );
					three.scene.add( line );
				}
			}
            
            function addLight() {
              // Lights

				three.scene.add( new THREE.AmbientLight( 0x202020 ) );

				var directionalLight = new THREE.DirectionalLight( 0xffffff );

				directionalLight.position.x = Math.random() - 0.5;
				directionalLight.position.y = Math.random() - 0.5;
				directionalLight.position.z = Math.random() - 0.5;

				directionalLight.position.normalize();

				three.scene.add( directionalLight );
            }
			
			function initCube() {
              
                cube = new THREE.Mesh(cubeGeo, cubeMaterial);
				
				cube.position.x = 50;
				cube.position.y = 50;
				cube.position.z = 50;
				
				// set the geometry to dynamic
				// so that it allow updates
				cube.geometry.dynamic = true;

				// changes to the vertices
				cube.geometry.__dirtyVertices = true;

				// changes to the normals
				cube.geometry.__dirtyNormals = true;
				
				three.scene.add(cube);
			}
			  
			
			function render() {
				 three.renderer.render(three.scene, three.camera);
			}
		         
		
		    window.onload = function(){
			
			    var renderer = new THREE.WebGLRenderer({antialias: true});
		        renderer.setSize(WIDTH, HEIGHT);
		        document.body.appendChild(renderer.domElement);
 				
				camera.position.x = -750;
				camera.position.y = -750;
				camera.position.z = 1500;

				camera.up = new THREE.Vector3(0, 0, 1);
                
				camera.lookAt(new THREE.Vector3(0, 0, 750));
								
				// scene
		        var scene = new THREE.Scene();

		        // plane
		        var plane = new THREE.Mesh(new THREE.PlaneGeometry(500, 500), new THREE.MeshBasicMaterial({
		            color: 0xeeeeee
		        }));
				plane.position.x = 250;
				plane.position.y = 250;
				plane.overdraw = true;
				scene.add(plane);
				
				
		        // create wrapper object that contains three.js objects
		        three = {
		            renderer: renderer,
		            camera: camera,
		            scene: scene,
		            plane: plane
		        };
                
                drawCoordinateSystem();
				
				drawBaseGrid();
                
                addLight();
                
				// initCube(scene);
                
				update();				
		    };
		</script>
    </head>
    <body>
        <canvas id="myCanvas" width="10" height="10">
        </canvas>
        <hr/>
        <h2>Controls:</h2>
		<input type="button" onClick="cubeLeft()" value="left" />
		<input type="button" onClick="cubeUp()" value="up" />
		<input type="button" onClick="cubeDown()" value="down" />
		<input type="button" onClick="cubeRight()" value="right" />
		<input type="button" onClick="cameraBack()" value="back" />
		<input type="button" onClick="cameraFront()" value="front" />
        <br />
        <h2>Positions:</h2>
        <textarea id="input"></textarea>
		<input type="button" onClick="renderPositions()" value="Render" />
    </body>
</html>