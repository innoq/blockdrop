<!DOCTYPE HTML>
<html>
    <head>
		<script src="js/Three.js">
		
		</script>
		<script>
		
			var WIDTH = 1000;
			var HEIGHT = 800;
			var backCamera = new THREE.PerspectiveCamera(45, WIDTH / HEIGHT, 45, 10000);
			var cubeGeo = new THREE.CubeGeometry(100, 100, 100);
			var cubeMaterial = new THREE.MeshNormalMaterial();
			var cubes = new Array();
			var three, cube;
			
			function cubeUp() {
				var x, y;		
			    x = cube.position.x;
				cube.position.x = x + 100;
				y = cube.position.y;
				cube.position.y = y + 100;
				cube.geometry.dynamic = true;
				render();
			}
			
			function cubeLeft() {
				var y;		
			    y = cube.position.y;
				cube.position.y = y + 100;
				cube.geometry.dynamic = true;
				render();
			}
			
			function cubeRight() {
				var x;		
			    x = cube.position.x;
				cube.position.x = x + 100;
				cube.geometry.dynamic = true;
				render();
			}
			
			function cubeDown() {
				var x, y;		
			    x = cube.position.x;
				cube.position.x = x - 100;
				y = cube.position.y;
				cube.position.y = y - 100;
				cube.geometry.dynamic = true;
				render();
			}
			
			function getPositions() {
				return new Array([0,0,1], [1,1,0], [2,3,4]);	
			}
			
			function clearGrid() {
				for(var i = 0; i < cubes.length; i++) {
					three.scene.removeObject(cubes[i]);
				}
				
				cubes = new Array();
			}
			
			function drawCube(pos) {              
				var c = new THREE.Mesh(cubeGeo, cubeMaterial);
				
                c.postion.x = pos[0];
				c.postion.y = pos[1];
				c.postion.z = pos[2];
                
                // set the geometry to dynamic
				// so that it allow updates
				c.geometry.dynamic = true;

				// changes to the vertices
				c.geometry.__dirtyVertices = true;

				// changes to the normals
				c.geometry.__dirtyNormals = true;
                
				three.scene.add(c);
				cubes.push(c);
			}
			
			function update() {
				
				var positions;
				
				clearGrid();
				
				positions = getPositions(); 
				
				for (var i = 0; i < positions.length; i++) {
					drawCube(positions[i]);
				}
				
				render();
			}
			
			function drawCoordinateSystem() {
				// COORDINATE SYS
				var line, lineGeometry;

				// x - red
				lineGeometry = new THREE.Geometry();
				lineGeometry.vertices.push( new THREE.Vertex() );
				lineGeometry.vertices.push( new THREE.Vertex( new THREE.Vector3( 1000, 0, 0 ) ) );
				line = new THREE.Line( lineGeometry, new THREE.LineBasicMaterial( { color : 0xff0000 } ) );
				three.scene.add( line );

				// y - green
				lineGeometry = new THREE.Geometry();
				lineGeometry.vertices.push( new THREE.Vertex() );
				lineGeometry.vertices.push( new THREE.Vertex( new THREE.Vector3( 0, 1000, 0 ) ) );
				line = new THREE.Line( lineGeometry, new THREE.LineBasicMaterial( { color : 0x00ff00 } ) );
				three.scene.add( line );

				// z - blue
				// lineGeometry = new THREE.Geometry();
				// lineGeometry.vertices.push( new THREE.Vertex() );
				// lineGeometry.vertices.push( new THREE.Vertex( new THREE.Vector3( 0, 0, 1000 ) ) );
				// line = new THREE.Line( lineGeometry, new THREE.LineBasicMaterial( { color : 0x0000ff } ) );
				// three.scene.add( line );
			}
			
			function drawBaseGrid() {
				var line, lineGeo, p1, p2;
				
				for (var i = 100; i <= 500; i = i + 100) {
					p1 = new THREE.Vertex( new THREE.Vector3( 0, i, 0 ) );
					p2 = new THREE.Vertex( new THREE.Vector3( 500, i, 0 ) );
					lineGeo = new THREE.Geometry();
					lineGeo.vertices.push( p1 );
					lineGeo.vertices.push( p2 );
				 	line = new THREE.Line( lineGeo, new THREE.LineBasicMaterial( { color : 0x000 } ) );
					three.scene.add( line );
				}
				
				for (var i = 100; i <= 500; i = i + 100) {
					p1 = new THREE.Vertex( new THREE.Vector3( i, 0, 0 ) );
					p2 = new THREE.Vertex( new THREE.Vector3( i, 500, 0 ) );
					lineGeo = new THREE.Geometry();
					lineGeo.vertices.push( p1 );
					lineGeo.vertices.push( p2 );
				 	line = new THREE.Line( lineGeo, new THREE.LineBasicMaterial( { color : 0x000 } ) );
					three.scene.add( line );
				}
			}
			
			function initCube() {
				
				cube.position.x = 50;
				cube.position.y = 50;
				cube.position.z = 50;
				
				// set the geometry to dynamic
				// so that it allow updates
				cube.geometry.dynamic = true;

				// changes to the vertices
				cube.geometry.__dirtyVertices = true;

				// changes to the normals
				cube.geometry.__dirtyNormals = true;
				
				three.scene.add(cube);
			}
			
			function render() {
				 three.renderer.render(three.scene, three.camera);
			}
		
		    window.onload = function(){
			
			    var angularSpeed = 0.2; // revolutions per second
		        var lastTime = 0;

		        var renderer = new THREE.WebGLRenderer();
		        renderer.setSize(WIDTH, HEIGHT);
		        document.body.appendChild(renderer.domElement);
		
		        var camera = new THREE.PerspectiveCamera(45, WIDTH / HEIGHT, 45, 10000);
		        
				camera.position.x = -750;
				camera.position.y = -750;
				camera.position.z = 1500;
				
				camera.up = new THREE.Vector3(0, 0, 1);
				camera.lookAt(new THREE.Vector3(0, 0, 750));
								
				// scene
		        var scene = new THREE.Scene();

		        // plane
		        var plane = new THREE.Mesh(new THREE.PlaneGeometry(500, 500), new THREE.MeshBasicMaterial({
		            color: 0xeeeeee
		        }));
				plane.position.x = 250;
				plane.position.y = 250;
				plane.overdraw = true;
				scene.add(plane);
				
				
		        // create wrapper object that contains three.js objects
		        three = {
		            renderer: renderer,
		            camera: camera,
		            scene: scene,
		            plane: plane
		        };
                
                drawCoordinateSystem();
				
				drawBaseGrid();
                
				initCube(scene);
                
				update();				
		    };
		</script>
    </head>
    <body>
        <canvas id="myCanvas" width="10" height="10">
        </canvas>
		<input type="button" onClick="cubeLeft()" value="left" />
		<input type="button" onClick="cubeUp()" value="up" />
		<input type="button" onClick="cubeDown()" value="down" />
		<input type="button" onClick="cubeRight()" value="right" />
    </body>
</html>